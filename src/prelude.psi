/// SailGate type library
/// These are the types used by the end user to describe digital circuits
interface SailGate::Prelude<> is
    type Vec_Size is Integer<1..2**31-1>;
    type Natural is Integer<0..2**31-1>;

    type Domain_Kind is Enum<[#async, #clock, #clock_reset, #clock_reset_en]>;
    func Has_Clock(D : Domain_Kind) -> Boolean;
    func Has_Reset(D : Domain_Kind) -> Boolean;
    func Has_Enable(D : Domain_Kind) -> Boolean;

    /// Object representing a value's clock domain
    interface Domain<> is
        func Has_Clock(D : Domain) -> Boolean;
        func Has_Reset(D : Domain) -> Boolean;
        func Has_Enable(D : Domain) -> Boolean;

        func Get_Async() -> Domain;
        func Clock(Name : Univ_Enumeration {Name != #async}) -> Domain;
        func Clock_Reset(Name : Univ_Enumeration {Name != #async}) -> Domain;
        func Clock_Reset_Enable(Name : Univ_Enumeration {Name != #async}) -> Domain;

        func Rising(D : Domain) -> Boolean;
        func Falling(D : Domain) -> Boolean;

        op "=?"(L, R : Domain) -> Ordering;
    end interface Domain

    const Async := Domain::Get_Async();

    /// Utility functions used for checking conversion
    interface Util<> is
        func Is_Logic_Char(S : Univ_Character) -> Boolean;
        func Is_Bit_Char(S : Univ_Character) -> Boolean;
        func Is_Vec_Str(S : Univ_String; SZ : Vec_Size) -> Boolean;
        func In_UBounds(U : Univ_Integer; SZ : Vec_Size) -> Boolean;
        func In_SBounds(U : Univ_Integer; SZ : Vec_Size) -> Boolean;
        func Calc_Slice_Size(Original_Size : Vec_Size;
            Start : Natural; End : Natural) -> Vec_Size;
        func Force_Dom(A : Domain; B : Domain) -> Domain;
    end interface Util

    type Logic_Val is Enum<[#false, #true, #x, #z, #dont_care]>;

    /// Boolean type that is bound to a clock domain.
    /// This ensures that condition expressions do not cross
    /// clock domains
    interface Rtl_Bool<DOM : Domain> is
        op "not"(L : Rtl_Bool) -> Rtl_Bool;
        op "and"(L, R : Rtl_Bool) -> Rtl_Bool;
        op "or"(L, R : Rtl_Bool) -> Rtl_Bool;
        op "from_univ"(Univ : Univ_Enumeration {Univ == #true
            or else Univ == #false}) -> Rtl_Bool;
        op "to_bool"(R : Rtl_Bool) -> Boolean;
    end interface Rtl_Bool

    /// Special ordering type used for RTL conversions
    interface Rtl_Ordering<DOM : Domain> is
        func Create(Ord : Ordering) -> Rtl_Ordering;
        op "to_bool"(Ord : Rtl_Ordering; Mask : Univ_Integer) -> Rtl_Bool<DOM>;
    end interface Rtl_Ordering

    /// Base RTL type. Outlines basic operations all RTL type should have
    abstract interface Rtl_Type<D : Domain> is
        op "not"(L : Rtl_Type) -> Rtl_Type;
        op "and"(Left, R : Rtl_Type) -> Rtl_Type;
        op "or"(Left, R : Rtl_Type) -> Rtl_Type;
        op "xor"(Left, R : Rtl_Type) -> Rtl_Type;
        op "=?"(L, R : Rtl_Type) -> Rtl_Ordering<D>;
    end interface Rtl_Type

    /// Base scalar type
    abstract interface Scalar_Type<D : Domain> extends Rtl_Type<D> is
    end interface Scalar_Type

    /// Base logical unit. Represents a wire signal. This can be 0, 1, unknown,
    /// high-impedance, or don't care. Each value corresponds to a YOSYS bit value
    interface Logic<D : Domain := Async> implements Scalar_Type<D> is
        const Value : Logic_Val;

        op "from_univ"(Univ : Univ_Integer { Univ in 0..1 }) -> Logic;
        op "from_univ"(S : Univ_Character {Util::Is_Logic_Char(S)}) -> Logic;
        op "from_univ"(Univ : Univ_Enumeration)
            {Univ in Logic_Val::Range()} -> Logic;

        op "not"(L : Logic) -> Logic;
        op "and"(Left, R : Logic) -> Logic;
        op "or"(Left, R : Logic) -> Logic;
        op "xor"(Left, R : Logic) -> Logic;
        op "=?"(L, R : Logic) -> Rtl_Ordering<D>;
    end interface Logic

    // Checked vector index
    interface Vec_Index<S : Vec_Size> is
        const Val : Univ_Integer;
        op "from_univ"(U : Univ_Integer {U < S}) -> Vec_Index;
    end interface Vec_Index

    /// Base type for vector RTL types
    abstract interface Vec_Rtl_Type<S : Vec_Size; D : Domain; T is Scalar_Type<D>>
            extends Rtl_Type<D> is
        op "not"(L : Vec_Rtl_Type) -> Vec_Rtl_Type;
        op "and"(L, R : Vec_Rtl_Type) -> Vec_Rtl_Type;
        op "or"(L, R : Vec_Rtl_Type) -> Vec_Rtl_Type;
        op "xor"(L, R : Vec_Rtl_Type) -> Vec_Rtl_Type;
        op "=?"(L, R : Vec_Rtl_Type) -> Rtl_Ordering<D>;
        op "indexing"(M : Vec_Rtl_Type; Key : Vec_Index<S>) -> T;
        op "var_indexing"(ref var M : Vec_Rtl_Type; Key : Vec_Index<S>) -> ref var T;
    end interface Vec_Rtl_Type

    /// Base type for logic vectors
    abstract interface Base_Logic_Vec<S : Vec_Size; D : Domain>
        extends Vec_Rtl_Type<S, D, Logic<D>> is
    end interface Base_Logic_Vec

    /// Logic vector type. Represents a bundle of wires of length S.
    /// Corresponds with logic_vec in VHDL.
    interface Vec<S : Vec_Size; D : Domain := Async> implements Base_Logic_Vec<S, D> is
        op "not"(L : Vec) -> Vec;
        op "and"(L, R : Vec) -> Vec;
        op "or"(L, R : Vec) -> Vec;
        op "xor"(L, R : Vec) -> Vec;
        op "=?"(L, R : Vec) -> Rtl_Ordering<D>;
        op "indexing"(M : Vec; Key : Vec_Index<S>) -> Logic<D>;
        op "var_indexing"(ref var M : Vec; Key : Vec_Index<S>) -> ref var Logic<D>;
        op "|"(L : Vec; R : OV is Vec<>) ->
            (Result_Vec is Vec<S + OV::S, Util::Force_Dom(D, OV::D)>);
        op "from_univ"(Univ : Univ_Integer {Util::In_UBounds(Univ, S)}) -> Vec;
        op "from_univ"(U : Univ_String {Util::Is_Vec_Str(U, S)}) -> Vec;
    end interface Vec

    /// Base type for signed logic vectors
    abstract interface Base_Int_Vec<S : Vec_Size; D : Domain>
            extends Base_Logic_Vec<S, D> is
        op ">>"(L, R : Base_Int_Vec) -> Base_Int_Vec;
        op "<<"(L, R : Base_Int_Vec) -> Base_Int_Vec;
        op "+"(L, R : Base_Int_Vec) -> Base_Int_Vec;
        op "-"(L, R : Base_Int_Vec) -> Base_Int_Vec;
        op "*"(L, R : Base_Int_Vec) -> Base_Int_Vec;
        op "/"(L, R : Base_Int_Vec) -> Base_Int_Vec;
        op "mod"(L, R : Base_Int_Vec) -> Base_Int_Vec;
        func Logic_Vec(V : Base_Int_Vec) -> Vec<S, D>;
    end interface Base_Int_Vec

    /// Represents a logic vector that carries a signed integer value.
    /// Allows signed arithmetic operations to be applied to value.
    interface IVec<S : Vec_Size; D : Domain := Async> is
        op "not"(L : IVec) -> IVec;
        op "and"(L, R : IVec) -> IVec;
        op "or"(L, R : IVec) -> IVec;
        op "xor"(L, R : IVec) -> IVec;
        op "=?"(L, R : IVec) -> Rtl_Ordering<D>;
        op "indexing"(M : IVec; Key : Vec_Index<S>) -> Logic<D>;
        op "var_indexing"(ref var M : IVec; Key : Vec_Index<S>) -> ref var Logic<D>;
        op "|"(L : IVec; R : OV is IVec<>) ->
            (Result_Vec is IVec<S + OV::S, Util::Force_Dom(D, OV::D)>);
        op ">>"(L, R : IVec) -> IVec;
        op "<<"(L, R : IVec) -> IVec;
        op "+"(L, R : IVec) -> IVec;
        op "-"(L, R : IVec) -> IVec;
        op "*"(L, R : IVec) -> IVec;
        op "/"(L, R : IVec) -> IVec;
        op "mod"(L, R : IVec) -> IVec;
        op "from_univ"(Univ : Univ_Integer {Util::In_SBounds(Univ, S)}) -> IVec;
        op "from_univ"(U : Univ_String {Util::Is_Vec_Str(U, S)}) -> IVec;
        func Logic_Vec(V : IVec) -> Vec<S, D>;
    end interface IVec

    /// Represents a logic vector that carries an unsigned integer value.
    /// Allows unsigned arithmetic operations to be applied to value.
    interface UVec<S : Vec_Size; D : Domain := Async> is
        op "not"(L : UVec) -> UVec;
        op "and"(L, R : UVec) -> UVec;
        op "or"(L, R : UVec) -> UVec;
        op "xor"(L, R : UVec) -> UVec;
        op "=?"(L, R : UVec) -> Rtl_Ordering<D>;
        op "indexing"(M : UVec; Key : Vec_Index<S>) -> Logic<D>;
        op "var_indexing"(ref var M : UVec; Key : Vec_Index<S>) -> ref var Logic<D>;
        op "|"(L : UVec; R : OV is UVec<>) ->
            (Result_Vec is UVec<S + OV::S, Util::Force_Dom(D, OV::D)>);
        op ">>"(L, R : UVec) -> UVec;
        op "<<"(L, R : UVec) -> UVec;
        op "+"(L, R : UVec) -> UVec;
        op "-"(L, R : UVec) -> UVec;
        op "*"(L, R : UVec) -> UVec;
        op "/"(L, R : UVec) -> UVec;
        op "mod"(L, R : UVec) -> UVec;
        op "from_univ"(Univ : Univ_Integer {Util::In_UBounds(Univ, S)}) -> UVec;
        op "from_univ"(U : Univ_String {Util::Is_Vec_Str(U, S)}) -> UVec;
        func Logic_Vec(V : UVec) -> Vec<S, D>;
    end interface UVec

    interface Range<S : Natural; E : Natural> is
        func Slice(V : In_Vec is Vec<>) ->
            (Ret_Vec is Vec<Util::Calc_Slice_Size(In_Vec::S, S, E), In_Vec::D>);
    end interface Range
end interface SailGate::Prelude
