import SailGate::Prelude;
import PSC::Reflection::*;
import SailGate::Sema::Sema_Error;
import SailGate::Names;
import SailGate::Sema::Util;
import SailGate::IR;
import SailGate::Util::Starts_With;
import SailGate::Util::Result;

class SailGate::Sema::Reader is
    type Align_Result is Result<IR::Alignment, Sema_Error>;

    const PLUS := "\"+\"";
    const MINUS := "\"+\"";
    const MULT := "\"*\"";
    const DIV := "\"/\"";
    const FROM_UNIV := "\"from_univ\"";

    /// Read alignment clause from annotation metadata
    func Read_Alignment(D : Tree {Kind(D) == #annotation}) -> Align_Result is
        const Anno_Source := Util::Find_Tree_Source(D);
        const Anno_Err := Align_Result::Err((
            Kind => #invalid_anno, Source => Anno_Source));

        // Find function call
        if Num_Operands(D) != 1 then
            return Anno_Err;
        end if

        const Invoc := Nth_Operand(D, 1);
        if Invoc is null or else Kind(Invoc) != #invocation then
            return Anno_Err;
        end if

        // Makes sure we're calling the right function
        const Call := Util::Get_Call_Operation(Invoc);
        if Call is null or else
                Util::Get_Decl_Name(Call) != Names::Functions::Align then
            return Anno_Err;
        end if

        var Dir : Prelude::Vec_Dir := #default;
        var Offset : Prelude::Natural := 0;

        // Loop through call operands and find 
        for I in 2..Num_Operands(Invoc) forward loop
            var Argument := Nth_Operand(Invoc, I);
            if Kind(Argument) == #reference then
                Argument := Nth_Operand(Argument,
                    Tree::Reference_Referent_Op);
            end if

            if Kind(Argument) == #identifier and then
                    Lit_Kind(Argument) == #enum_literal then
                case Identifier(Argument) of
                    ["#default"] =>
                        Dir := #default;
                    ["#up"] =>
                        Dir := #up;
                    ["#down"] =>
                        Dir := #down;
                end case
                continue loop;
            end if

            const Int_Val := Read_Const_Int(Argument);
            if Int_Val is null or else Int_Val < 0 then
                const Arg_Source := Util::Find_Tree_Source(Argument);
                return Align_Result::Err((
                    Kind => #non_const_val, Source => Arg_Source));
            end if
            Offset := Int_Val;
        end loop

        return Align_Result::Ok((Dir => Dir, Offset => Offset,
            Source => Anno_Source));
    end func Read_Alignment

    /// Reads domain out from type actual parameter. This is
    /// effectively a wrapper around Dom_Obj and Dom_Param
    func Read_Dom_Param(T : Tree) -> Domain_Result is
        const Src := Util::Find_Tree_Source(T);
        const Dom_Err := Domain_Result::Err((
            Source => Src, Kind => #invalid_dom_arg));

        if Kind(T) == #invocation then
            const Invoc_Op := Util::Get_Call_Operation(T);
            case Util::Get_Decl_Name(Invoc_Op) of
                // Function used to check slice size in prelude
                [Names::Functions::Force_Dom] =>
                    const Left_Err := Read_Dom_Param(Nth_Operand(T, 2));
                    if Is_Err(Left_Err) then
                        return Left_Err;
                    end if

                    const Right_Err := Read_Dom_Param(Nth_Operand(T, 3));
                    if Is_Err(Right_Err) then
                        return Right_Err;
                    end if

                    if Ok(Left_Err).Kind != #async then
                        return Left_Err;
                    else
                        return Right_Err;
                    end if
                [..] =>
                    return Dom_Err;
            end case
        end if

        const Sym := Util::Get_Symbol(T);
        const Sym_Def := Definition(Sym);
        const Def_Decl := Decl_Of(Sym_Def);

        case Kind(Sym) of
            [#object_sym_kind] =>
                {Def_Decl not null and Kind(Def_Decl) == #object}
                return Dom_Obj(Def_Decl);
            [#param_sym_kind] =>
                {Def_Decl not null and Kind(Def_Decl) == #object}
                return Dom_Param(Def_Decl);
        end case

        return Dom_Err;
    end func Read_Dom_Param
exports
    func Dom_Param(D : Decl) -> Domain_Result is
        const Dom_Name := Util::Get_Decl_Name(D);
        var Dom_Kind : Prelude::Domain_Kind := #async;
        const T := Tree_Of(D);
        {Kind(T) == #param_decl}

        const Param_Type := Nth_Operand(T, Tree::Param_Decl_Type_Op);

        // Check that param is of correct type
        const Param_Desc := Resolved_Type(T);
        if Param_Desc is null or else Name(Param_Desc) != Names::Types::Domain then
            return Domain_Result::Err((
                Source => Util::Find_Tree_Source(Param_Type),
                Kind => #invalid_param_dom_type));
        end if

        // Check that param has no initial value
        const Param_Init := Nth_Operand(T, Tree::Param_Decl_Value_Op);
        if Param_Init not null then
            return Domain_Result::Err((
                Source => Util::Find_Tree_Source(Param_Init),
                Kind => #invalid_param_dom_init));
        end if

        // Check param annotation. We should see either nothing or a call to
        // Clock, Clock_En, or Clock_Reset_En with the domain as the parameter
        const Dom_Constr := Post_Annotation(T);
        if Dom_Constr not null then
            const Call_Err : Sema_Error := (Kind => #invalid_param_dom_constr,
                Source => Util::Find_Tree_Source(Dom_Constr));

            if Num_Operands(Dom_Constr) != 1 then
                return Domain_Result::Err(Call_Err);
            end if

            // Return error if we don't find a call that fits
            const Call := Nth_Operand(Dom_Constr, 1);
            if Kind(Call) != #invocation or else Num_Operands(Call) != 2 then
                return Domain_Result::Err(Call_Err);
            end if

            // The resolved interp for this annotation is going to be
            // null because it is never resolved by ParaSail.
            // This is fixed by one of my pull requests in review,
            // but for now:
            const Call_Func := Nth_Operand(Call, 1);
            case Identifier(Call_Func) of
                [Names::Functions::Clock | "Prelude::Clock" | "Clock"] =>
                    Dom_Kind := #clock;
                [Names::Functions::Reset | "Prelude::Reset" | "Reset"] =>
                    Dom_Kind := #clock_reset;
                [Names::Functions::Clk_Rst_En | "Prelude::Clk_Rst_En" | "Clk_Rst_En"] =>
                    Dom_Kind := #clock_reset_en;
                [..] =>
                    return Domain_Result::Err(Call_Err);
            end case

            // First and only operand must be the domain defined by the param
            const Call_Op := Nth_Operand(Call, 2);
            if Kind(Call_Op) != #identifier or else Identifier(Call_Op) != Id(D) then
                return Domain_Result::Err(Call_Err);
            end if
        end if

        return Domain_Result::Ok((Name => Id(D),
            Kind => Dom_Kind, Full_Name => Dom_Name));
    end func Dom_Param

    func Dom_Obj(D : Decl) -> Domain_Result is
        const T := Tree_Of(D);
        const Dom_Name := Util::Get_Decl_Name(D);
        const Desc := Resolved_Type(T);
        const Obj_Err := Domain_Result::Err((
            Kind => #invalid_dom_obj,
            Source => Decl_Source_Pos(D)));

        // Makes sure the type is right. We should have a type desc for this
        if Name(Desc) != Names::Types::Domain then
            return Obj_Err;
        end if

        // Make sure our domain is a call
        const Obj_Value := Nth_Operand(T, Tree::Obj_Decl_Value_Op);
        if Obj_Value is null or else Kind(Obj_Value) != #invocation then
            return Obj_Err;
        end if

        const Obj_Val_Resolved := Resolved_Interp(Obj_Value);
        if Obj_Val_Resolved is null then
            return Obj_Err;
        end if

        // Find out which call they made. This determines the domain type
        const Obj_Val_Call := Call_Operation(Obj_Val_Resolved);
        var Dom_Kind : Prelude::Domain_Kind := #async;
        case Util::Get_Decl_Name(Obj_Val_Call) of
            [Names::Functions::Clock_Create] =>
                Dom_Kind := #clock;
            [Names::Functions::Reset_Create] =>
                Dom_Kind := #clock_reset;
            [Names::Functions::Clk_Rst_En_Create] =>
                Dom_Kind := #clock_reset_en;
            [Names::Functions::Async_Create] =>
                Dom_Kind := #async;
            [..] =>
                return Obj_Err;
        end case

        return Domain_Result::Ok((Name => Id(D), 
            Kind => Dom_Kind, Full_Name => Dom_Name));
    end func Dom_Obj

    func Type_Is_Rtl(D : Decl) -> Boolean is
        const Type_Mod := Associated_Module(D);
        const Type_Mod_Name := Util::Get_Decl_Name(Type_Mod);
        case Type_Mod_Name of
            [Names::Types::Logic | Names::Types::Bool |
                    Names::Types::SVec | Names::Types::UVec |
                    Names::Types::LVec] =>
                return #true;
            [..] =>
                return #false;
        end case
    end func Type_Is_Rtl

    func Type_To_Rtl(D : Decl; Pos : Source_Position) -> Type_Result is
        const Type_Mod := Associated_Module(D);
        const Type_Mod_Name := Util::Get_Decl_Name(Type_Mod);
        const Type_Params := Trees_Of_Actuals(D);

        var Scalar_Type : optional IR::Scalar_Type := null;
        case Type_Mod_Name of
            [Names::Types::Logic] =>
                Scalar_Type := #logic;
            [Names::Types::Bool] =>
                Scalar_Type := #bool;
        end case

        if Scalar_Type not null then
            const Dom_Tree := Type_Params[1];
            const Dom_Err := Read_Dom_Param(Dom_Tree);
            if Is_Err(Dom_Err) then
                return Type_Result::Err(Err(Dom_Err));
            end if
            const Type := IR::Type::Create(Scalar_Type,
                Ok(Dom_Err), Pos);
            return Type_Result::Ok(Type);
        end if

        var Vec_Type : IR::Vec_Type::Type_Kind := #logic;
        case Type_Mod_Name of
            [Names::Types::SVec] =>
                Vec_Type := #int;
            [Names::Types::UVec] =>
                Vec_Type := #uint;
            [Names::Types::LVec] =>
                Vec_Type := #logic;
            [..] =>
                return Type_Result::Err((Source => Pos,
                    Kind => #invalid_rtl_type));
        end case

        const Size_Tree := Type_Params[1];
        var Size := Read_Const_Int(Size_Tree);
        if Size is null then
            return Type_Result::Err((Source => Pos,
                Kind => #invalid_rtl_type));
        end if

        const Dom_Tree := Type_Params[2];
        const Dom_Err := Read_Dom_Param(Dom_Tree);
        if Is_Err(Dom_Err) then
            return Type_Result::Err(Err(Dom_Err));
        end if

        const Type := IR::Type::Create(Vec_Type,
            Size, Ok(Dom_Err), Pos);
        return Type_Result::Ok(Type);
    end func Type_To_Rtl

    /// Read alignment and add it to type
    func Add_Alignment(var T : IR::Type; Align_Tree : optional Tree)
            -> optional Sema_Error is
        if Align_Tree is null then
            return;
        end if

        const Align_Source := Util::Find_Tree_Source(Align_Tree);
        if T.Kind != #vec then
            return (Kind => #field_non_vec_align, Source => Align_Source);
        end if

        const Alignment_Result := Read_Alignment(Align_Tree);
        if Is_Err(Alignment_Result) then
            return Unwrap_Err(Alignment_Result);
        end if

        const Vec_Type := Get_Vec(T);
        const Alignment := Ok(Alignment_Result);

        const New_Type := IR::Type::Create(Vec_Type.Kind, Vec_Type.Size,
            T.Dom, T.Source, Alignment);
        T := New_Type;
    end func Add_Alignment

    func Read_Const_Int(T : Tree) -> optional Univ_Integer is
        if T is null then
            return null;
        end if

        case Kind(T) of
            [#binary] =>
                const Right := Read_Const_Int(Nth_Operand(T, Tree::Binary_Right_Op));
                const Left := Read_Const_Int(Nth_Operand(T, Tree::Binary_Left_Op));
                if Right not null and then Left not null then
                    case Binary_Op(T) of
                        [#plus_op] => return Left + Right;
                        [#minus_op] => return Left - Right;
                        [#times_op] => return Left * Right;
                        [#divide_op] => return Left / Right;
                        [#power_op] => return Left ** Right;
                        [#left_shift_op] => return Left << Right;
                        [#right_shift_op] => return Left >> Right;
                    end case
                end if
            [#unary] =>
                const Val := Read_Const_Int(Nth_Operand(T, Tree::Unary_Val_Op));
                if Val not null then
                    case Unary_Op(T) of
                        [#plus_op] => return Val;
                        [#minus_op] => return -Val;
                    end case
                end if
            [#identifier] =>
                if Lit_Kind(T) not null and then Lit_Kind(T) == #integer_literal then
                    return Univ_Integer::From_String(Identifier(T));
                end if
            [#invocation] =>
                const Invoc_Op := Util::Get_Call_Operation(T);
                const Invoc_Mod := Associated_Module(Invoc_Op);
                const Func_Id := Id(Invoc_Op);

                // Check for generic "integer" operation invocations
                case Func_Id of
                    [Names::Ops::Plus | Names::Ops::Minus | Names::Ops::Multiply |
                            Names::Ops::Divide] =>
                        const Left := Read_Const_Int(Nth_Operand(T, 2));
                        const Right := Read_Const_Int(Nth_Operand(T, 3));
                        if Right not null and then Left not null then
                            case Func_Id of
                                [Names::Ops::Plus] => return Left + Right;
                                [Names::Ops::Minus] => return Left - Right;
                                [Names::Ops::Multiply] => return Left * Right;
                                [Names::Ops::Divide] => return Left / Right;
                            end case
                        end if
                    [Names::Ops::From_Univ] =>
                        return Read_Const_Int(Nth_Operand(T, 2));
                end case

                case Util::Get_Decl_Name(Invoc_Op) of
                    // Function used to check slice size in prelude
                    [Names::Functions::Calc_Slice_Size] =>
                        const Left := Read_Const_Int(Nth_Operand(T, 3));
                        const Right := Read_Const_Int(Nth_Operand(T, 4));
                        if Right not null and then Left not null then
                            return |Left - Right| + 1;
                        end if
                end case
        end case
        return null;
    end func Read_Const_Int
end class SailGate::Sema::Reader
